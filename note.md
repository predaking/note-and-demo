# 目录

+ javascript
+ React
+ database
+ other

## javascript

### Number

#### 为什么0.1 + 0.2 不等于 0.3

在js中浮点数使用IEEE754双精度标准表示的，十进制小数相加是要转化为二进制进行存储与计算的，然后在计算完之后转回十进制时就会产生精度问题

### Array

#### 改变原数组

`push`
`pop`
`shift`
`unshift`
`splice`
`reverse`
`sort`
`fill`

#### 不改变原数组

`reduce`
`some`
`every`
`slice`
`concat`
`find`
`entries`
`filter`
`repeat`
`toUpperCase`
`toLowerCase`


#### 可能改变原数组
`forEach`

### String

+ `String.prototype.charAt`与下标方式获取字符有何区别？

区别如下：
1、IE6-8（未经测试）不兼容下标获取，均返回`undefined`，`charAt`则可以正常使用
2、当查询字符超出字符串范围时，`charAt`返回空字符串`''`，而下标获取到的值为`undefined`
3、下标获取会造成误解，让人误以为目标是数组，且可写

### Function

+ 关于箭头函数：

1、箭头函数没有自己的this，arguments，super或new.target。
2、它的this、arguments都是在定义函数时绑定外层的this和arguments，而不是在执行过程中绑定的，所以不会因为调用者不同而发生变化。
3、箭头函数若想得到自身的入参列表arguments，必须使用剩余参数表示法。
4、箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数

+ 关于纯函数：

函数式编程中，改变或变更叫做 mutation，这种改变的结果叫做“副作用”（side effect）。 理想情况下，函数应该是不会产生任何副作用的 pure function

### 尾调用与尾递归

函数返回非单纯的函数调用（类似return b() + 1;）会使得执行栈存储每次调用的记录，太占用内存。
所以需要进行尾调用优化，使得每次调用都用内层调用替换外层调用，这样始终只需存储一条调用记录，但是
只是在严格模式下生效，因为非严格模式下会有arguments与func.caller记录调用信息。
尾递归可以通过添加参数默认值、函数柯里化等方式实现

### 杂项

#### script标签的defer与async属性的用法与区别

两者同为异步加载脚本，只有defer属性是等文档所有元素渲染完成之后，DOMContentLoaded事件执行之前才
开始执行

#### script标签的crossOrigin属性的作用

为了能捕获到脚本内部具体的错误信息，可选值有：anonymous、use-credentials。设置该属性后脚本
所在的服务器也要设置Access-Control-Allow-Origin属性才可以达到目的

## React

### 杂项

#### jsx是什么？react为何推荐用jsx代替js？

JSX为`React.createElement()`的语法糖

JSX可以更好地描述UI本来就应该具有的交互形式，React认为渲染逻辑与UI逻辑本身就存在耦合，比如在
UI上面绑定事件，组件状态发生变化后通知UI进行相应的变化，以及在UI中展示准备好的数据。

#### React setState是同步还是异步？过程是什么样的？

1、在React合成事件中已经生命周期中的操作是异步的，计时器及js原生事件中是同步的。实际更新需要根据`isBatchUpdate`判断该同步更新还是异步更新

2、setState过程：更新state，创建virtual Dom，并利用diff算法比对差异，决定渲染哪一部分以及如何渲染，最后形成最新的UI。

## 数据库基础

+ 事务（transaction）的四大原则（ACID）：

1、原子性（atomicity）：事务往往包含许多操作，事务成功的条件是事务包含的所有操作都完成，只要有
任何一步操作失败事务都算失败，需要回滚；

2、一致性（consistency）：数据库要一直处于一致的状态，事务的执行要遵循数据库一致性，例如对于a
+b=10约束，如果事务修改了a，那么也必须修改b使结果一致，否则事务失败；

3、独立性（isolation）：数据库的并发事务不会相互影响，如果一个事务正在访问的数据库正在被修改，
只要正在做修改的事务并未提交成功那么其他并发的事务访问的数据就不会改变，即不会受到未提交事务的影
响；

4、持久性（durability）：事务一旦提交成功，那么对数据库的改变是永久的，即使发生宕机也不影响。

## other

### 性能优化

+ 前端性能优化方式有哪些？？？

1、减少http请求
- 尽量减少外部（第三方）脚本数量
- 尽可能分别合并js与css到一个文件
- 尽可能使用图标代替图片
- 利用CSS sprites代替多张图片
- 图片懒加载
- 缓存请求结果
- 使用内容分发网络CDN
- 用http2代替http1

2、压缩字体文件

3、

### http各版本区别

http0.9特性：
- 只支持GET请求
- 只支持服务端返回HTML的字符串（只支持文本传输）
- 默认端口为80
- 服务端发送完毕即关闭连接

http1.0特性：
- 支持传输图像、视频、二进制文件等多种类型资源
- 引入POST与HEAD命令
- 请求携带了header信息（包含了一系列字段信息：Content-Type、Content-Encoding等）

http1.1特性：
- 持久连接（TCP连接默认保持keep-alive，最多同时允许存在同个域名下4-6个持久请求连接，需要主动关闭）
- pipelining（客户端可以在一个TCP连接同时发送多个请求，服务端还是按序相应）
- 分块传输编码（通过设置Transfer-Encoding: chunked，逐块返回结果，以“流”（stream）取代
“缓存”（buffer））
- 增加了PUT、DELETE、OPTIONS等类型请求

http2特性：

- 多路复用（多个请求共用同一个TCP连接，而且不需要保持顺序，可以防止队头阻塞，充分利用带宽资源）
- 头部压缩（采用HPACK算法对报文头部进行压缩，缩减体积，节省带宽，提高效率，相同的字段以后只需要
发送一个建立好的索引号）
- 采用二进制数据帧（将消息组织成并行数据流，每个流又拆成二进制帧进行传输，更容易解析）
- 服务端推送（服务端在建立好TCP连接后可主动向客户端推送消息）

http3特性：
- 利用UDP协议的高效性在其上推行QUIC协议，并利用重传机制解决UDP不可靠传输问题
- 0 RTT建立连接

相关协议：
- SPDY协议：http2的前身，属于TCP协议之上，HTTP协议之下的会话层协议
- QUIC协议：http3的核心，属于UDP协议之上，HTTP协议之下的会话层协议
- HTTPS协议：基于SSL的http协议，具备防泄密（非明文传输）、防篡改（保证数据完整性）、防假冒
（身份验证）的特性
- SSL协议：安全套接层
- TLS协议：安全传输协议，SSL3.0的别名

### DNS解析过程

1、浏览器要将域名解析为IP地址，首先向本地DNS发起请求，本地DNS查询缓存，若没有找到，则下一步
2、本地DNS依次向根DNS服务器、顶级DNS服务器、权限DNS服务器发起请求，获取网站服务器的IP地址
3、本地DNS服务器将获取到的IP地址返回给浏览器，之后浏览器向该IP地址发起请求并得到资源

### 内容分发网络（CDN）与DNS解析

CDN的目的是在不同位置部署服务器的情况下让用户能够访问最近的服务器从而缩短请求时间
1、如果部署了GSLB（全局负载均衡系统），那么DNS解析过程中最后权限服务器返回的是该GSLB的IP地址，
2、随后GSLB根据本地DNS服务器的IP地址确定用户所处的位置，指定离其最近的SLB（本地负载均衡系统）
集群进一步进行DNS解析，并将其IP地址返回给本地DNS服务器
3、本地DNS收到IP地址后将其返回给浏览器，之后浏览器根据该IP向SLB发起请求
4、SLB根据请求资源与路径选出最优的缓存服务器返回给浏览器
5、浏览器将请求地址再重定向到该缓存服务器
6、如果该缓存服务器有浏览器请求的资源则直接返回，如没有则缓存服务器会向源服务器拉取最新资源并返
回浏览器并缓存在本地

### 浏览器缓存（强缓存&协商缓存）

首次请求根据expires与cache-control判断是否过期，若不过期则直接使用缓存（强缓存）；若过期则根
据last-modified/last-modified-since或Etag和if-None-Match确认资源是否被修改过（协商缓存）
若修改过则重新拉取资源，返回200，否则使用缓存，返回304

### 信息安全

#### XSS与CRSF攻击区别

XSS：跨站脚本攻击
攻击者通过url或评论区等地方注入攻击内容（html或js代码块），从而达到盗用cookie的目的

防范：
对url及用户输入内容进行encode，保证编码后的内容为纯字符串
过滤用户输入的内容：比如script标签等

CRSF：跨站请求伪造
首先需要用户成功登录到目标网站，在用户处产生cookie，然后用户访问恶意网站，恶意网站需要向目标网
站发起请求，所以用户在不知情的情况下向目标网站发起了请求，从而攻击者利用用户cookie达到了访问目
标服务器的目的

防范：
添加token机制，登录时服务端下发token，之后客户端每次请求都带上该token，服务器收到请求后对比
token，不相同则拒绝请求
cookie设置httpOnly，所有来自客户端脚本的访问都会被禁止
验证referer，服务器只处理指定网站发起的请求

https://blog.csdn.net/hugo233/article/details/114272109
