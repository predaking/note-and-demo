# 目录

+ CSS
+ SCSS

## CSS

### Flex弹性盒子

#### 父元素上的属性

+ `display`：定义元素的呈现方式

| 值 | 含义
| - | -
| flex | 块级弹性盒子，父元素独占一行，默认宽度100%
| inline-flex | 内联弹性盒子，父元素宽度取决于全部子元素宽度

+ `flex-direction`：定义子元素的排列方向（主轴方向）

| 值 | 含义
| - | -
| row（默认） | 横向排列
| column | 纵向排列
| row-reverse | 横向逆序排列
| column-reverse | 纵向逆序排列

+ `flex-wrap`：定义子元素超出一排或一列后如何排列

| 值 | 含义
| - | -
| nowrap（默认） | 不换行
| wrap | 自动换行
| wrap-reverse | 自动反向换行，排列结果与`wrap`轴对称

+ `flex-flow`：`flex-direction`与`flex-wrap`的结合

| 值 | 含义
| - | -
| row wrap（默认） | 横向排列且自动换行

+ `align-content`：定义多条轴线子元素的排列方式（一般是子元素排不满产生了换行），可选值与`align-items`相同

#### 子元素上的属性

+ `flex-grow`：定义子元素如何占据主轴剩余空间

| 值 | 含义
| - | -
| 0（默认） | 保持元素原有宽度
| >= 1 | 若只有一个子元素，则占满整个父元素宽度，多个子元素计算百分比（宽度属性失效）

+ `flex-shrink`：定义父元素空间不足时，子元素的缩小比例

| 值 | 含义
| - | -
| 1（默认） | 子元素自动缩小宽度
| 0 | 子元素保持原有宽度
| >1 | 子元素按百分比缩小

+ `flex-basis`：定义为子元素分配多余空间时，计算子元素是否还有剩余空间（主轴上作用等同于width）

| 值 | 含义
| - | -
| auto（默认） | 子元素保持原有大小
| %\|px | 指定百分比或宽度

+ `flex`：`flex-grow`、`flex-shrink`、`flex-basis`三个属性缩写

| 值 | 含义
| - | -
| 0 1 auto（默认） | 子元素保持原大小，剩余空间不足时自动缩小；剩余空间充足时不自动拉伸
| 1\|1 1 0% | 子元素均分剩余空间

+ `align-self`：覆盖`align-items`属性，允许子元素有单独的对齐方式

| 值 | 含义
| - | -
| auto（默认） | 继承父元素`align-items`的值
| flex-start | 顶部对齐
| center | 居中对齐
| flex-end | 底部对齐
| stretch | 拉伸对齐
| baseline | 以第一个元素内部文字为基准对齐

## SCSS

### 样式复用手段

+ 混合宏（Mixins）

特点：类似于函数，通过`@mixin`声明，`@include`引用。
可以接受参数，并生成相应的 CSS 代码。
不会合并相同的样式代码，可能导致 CSS 代码冗余。

应用场景：适用于需要传递参数来生成不同样式的场景。
当样式代码块中涉及到变量，且这些变量需要根据不同情况动态变化时，混合宏是最佳选择。

+ 继承（Extend）

特点：通过`@extend`指令实现样式继承。
可以将一个选择器的所有样式复制到另一个选择器上。
编译后的 CSS 会将相同的样式合并，减少代码冗余。

应用场景：适用于不需要传递参数，且已经存在基类样式的场景。
当多个选择器需要共享相同的样式时，使用继承可以避免代码重复。

与混合宏的区别：
继承不会产生代码冗余，而混合宏在多次引用时可能会导致相同样式代码的重复。
继承只能继承已存在的选择器样式，而混合宏可以定义全新的样式代码块。

+ 占位符（Placeholder Selectors）

特点：使用%符号声明，通过@extend指令引用。
如果未被引用，则不会出现在编译后的 CSS 中。
与继承类似，但占位符本身不会在 CSS 中生成任何代码，直到被`@extend`引用。

应用场景：适用于需要避免在 CSS 中生成无用选择器代码的场景。
当存在多个可能不会全部使用的样式代码块时，使用占位符可以避免生成未使用的 CSS 代码。

与继承的异同：

占位符与继承都通过`@extend`引用，但占位符本身不生成 CSS 代码，而继承会生成基类选择器的 CSS 代码。
占位符的使用更加灵活，可以避免不必要的 CSS 代码生成，减少文件大小。

总结
混合宏适用于需要传递参数来动态生成样式的场景，但可能导致代码冗余。
继承适用于不需要传递参数，且已经存在基类样式的场景，可以合并相同样式，减少代码冗余。
占位符则是一种更加灵活的样式复用手段，通过避免生成未使用的 CSS 代码来优化最终的 CSS 文件大小。